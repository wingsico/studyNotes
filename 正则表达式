#find ./ -name *.txt
在当前目录下查找所有的txt文件

#字面量
var reg = /\bis\b/g;

#构造函数
var reg = new RegExp('\\bis\\b','g')

#修饰符 - 只读
g: global 全文搜索,不添加则只搜索第一个 默认false
i: ignorCase 忽略大小写，默认大小写敏感 默认false
m: multiline 多行匹配 默认false
lastIndex: 是当前表达式匹配内容的最后一个字符的下一个位置
source:正则表达式的文本字符串

#元字符
元字符的含义在不同场景有不同的含义
正则表达式由两种基本字符类型组成
 - 原义文本字符 类似a,1等
 - 元字符
元字符是在正则表达式中有特殊含义的非字母字符
 * + ? $ ^ . | \ ( ) { } [ ] \t \v \n \r \0 \f \cX(ctrl + x)

#字符类
使用元字符[]构建一个简单的类
类是指符合某些特性的对象，一个泛指，而不是特指某个字符
表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符

#字符类取反
使用元字符^创建 反向类/负向类
反向类的意思是不属于某类的内容
表达式[^abc]表示 不是字符a或b或c的内容

#范围类
[a-z]来连接两个字符表示 从a到z的任意字符
这是个闭区间，也就是包含a和z本身
在[]组成的类内部是可以连写的[a-zA-Z]表示从a到z和从A到Z的任意字符

#预定义类
. 等价于[^\r\n] 除了回车符和换行符之外的所有字符
\d 等价于[0-9] 数字字符
\D 等价于[^0-9] 非数字字符
\s [\t\n\x0B\f\r] 空白符
\S [^\t\n\x0B\f\r] 非空白符
\w [a-zA-Z_0-9] 单词字符（字母、数字下划线）
\w [^a-zA-Z_0-9] 非单词字符

#边界
^ 以xxx开始
$ 以xxx结束
\b 单词边界
\B 非单词边界

#量词
? 出现零次或一次（最多出现一次）
+ 出现一次或多次（至少出现一次）
* 出现零次或多次（任意次）
{n} 出现n次
{n,m} 出现n到m次
{n,} 至少出现n次
{0,n} 最多出现n次

#贪婪模式
\d{3,6} 在匹配的时候会尽可能多的匹配，直到匹配失败
当贪婪模式匹配字符串的时候当已经不够最大次数的匹配的时候，会选择更小次数的匹配。
比如：'123456789'.replace(/\d{3,6}/g,'x') 返回 "xx",由于是global，能够匹配到最大次6次，即"123456",替换成"x"，匹配到后并不会停止而是继续匹配，剩下'789'能被最小次三次匹配到，再次被替换成"x"。所以最后是"xx"

#非贪婪模式
与贪婪模式相反，每次都尽可能少的匹配，直到匹配失败

#分组
使用()可以达到分组的功能，使量词作用于分组
想让box匹配三次，即box{3}是行不通的，它只会匹配x三次
那么使用分组 (box){3}就可以了

#或
使用|可以达到或的效果
分组与或配合使用
比如 byronsy 和 bycansy 我都要匹配
则可以这样写: by(ro|ca)nsy

#反向引用 - 利用分组
需求： 2015-12-25 => 12/25/2015
'2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2}),'$2/$3/$1')  就可以了
$代表分组的内容 第一个分组就是 $1 以此类推

#忽略分组
不希望捕获某些分组，只需要在分组内加上 ?: 就可以
比如(?:byron).(ok) 则ok为 $1,byron被忽略

#前瞻
* 正则表达式从文本头部向尾部开始解析，文本尾部方向，成为"前"
* [前瞻]就是在正则表达式匹配到规则的时候，向前检查是否符合[断言],后顾/后瞻方向相反
* JavaScript 不支持后顾
* 符合和不符合特定断言称为 肯定/正向 匹配和 否定/负向 匹配
正向前瞻   exp(?=assert) 【assert代表断言 不会被匹配进去 】
负向前瞻   exp(?!assert) 
比如 \w(?=\d) 意思是匹配一个单词字符，并且它的后面是数字的 比如说 a4,58等 只会替换a和5
\w(?!\d) 意思是匹配一个单词字符，并且它的后面不是数字的 比如说 4a,9c等 只会替换4和9

#test 和 exec方法
var reg1 = /\w/;
reg1.test('a') // true 
test() 参数为一个字符串 测试这个字符串中是否含有满足匹配条件的，如果有，返回true，如果没有，返回false
但是 当加上全局修饰符g的时候，情况发生了改变(在非全局情况下lastIndex不生效)
来看一个例子:
var reg2 = /\w/g; 
执行一遍 reg2.test('a') // 返回true
执行第二遍 reg2.test('a') // 返回false
这是为什么呢？
这是因为正则表达式内部属性lastIndex在起作用
当没有启用全局匹配修饰符g的时候，只要匹配到符合条件的就停止，返回true，不会再继续匹配
当启用g的时候，成功匹配一次后，由于lastIndex的位置发生改变，从0变成了1，由于索引1上没有符合条件的字符，则返回false，当test()返回false的时候，lastIndex重新置为0，则再次执行 reg2.test('a') 又从索引0开始匹配，再次匹配到a，返回true

#RegExp.prototype.exec(str)
使用正则表达式模式对字符串执行搜索，并将更小全局的RegExp对象的属性以反映匹配结果
如果没有匹配到文本则返回null,否则返回一个结果数组：数组会有两个额外的属性
  - index 声明匹配文本的第一个字符的位置
  - input 存放被检索的字符串 string 

#非全局调用
* 调用非全局的RegExp对象的exec()时，返回数组
* 第一个元素是与正则表达式相匹配的文本
* 第二个元素是与RegExpObject的第一个子表达式相匹配的文本(如果有的话)
* 第三个元素是与RegExp对象的第二个子表达式相匹配的文本(如果有的话)，以此类推
举个例子: 
var reg3 = /\d(\w)\d/; // 匹配数字+字母+数字
var ts = '*1a2b3c'
var ret = reg3.exec(ts);
console.log(reg3.lastIndex + '\t' + ret.index + '\t' + ret.toString()); 
打印出来的是 0 1 1a2,a
解释一下： 0 代表着reg3的lastIndex属性，因为reg3不在全局调用上，所以lastIndex属性是不起作用的
1 代表着匹配到的文本的第一个字符的索引位置，也就是1a2，其中1位于索引1上
1a2,a则是将ret数组转换成了字符串
接下来说明ret数组
可以console.log(ret)看一下，是一个数组，含有两个元素
第一个元素: "1a2" 代表着与正则表达式相匹配的文本
第二个元素: "a" 因为正则表达式中有一个分组(\w) 则它会单独打印出来，也就是"1a2"中的"a"
如果有第二个分组，并且匹配到了的话就会有第三个元素，为第二个分组的字符，以此类推。

##字符串对象方法

#String.prototype.search(reg)
seach()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串
方法返回第一个匹配结果index，查找不到返回-1
search()方法不执行全局匹配，它将忽略标志g,并且总是从字符串的开始进行检索

#String.prototype.match(reg)
match()方法将检索字符串，以找到一个或者多个与regexp匹配的文本，是否具有g修饰符对结果影响很大
在非全局调用下,和exec很相似，只是把字符串和正则调换了一下位置,返回的数组元素以及属性都是一样的
但是在全局调用下却有很大不一样
* 如果regexp具有标志 g 则match()方法将执行全局检索，找到字符串中所有匹配的字符串
* 没有找到任何匹配的子串，则返回null
* 找到了一个或者多个匹配子串，则返回一个数组
* 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性(忘记这两个属性？网上翻翻复习一下)

#String.prototype.split(reg)
我们检测使用split方法把字符串分割为字符数组
在一些复杂的分割情况下我们可以使用正则表达式解决：
'a1b2c3d'.split(/\d/) // ["a","b","c"]

#String.prototype.replace()
String.prototype.replace(str,replaceStr)
String.prototype.replace(reg,replaceStr)
String.prototype.replace(reg,function)

前两个是比较常用的，我们来解释最后一个
function:
function会在每次匹配替换的时候调用，有四个参数
1、匹配字符串
2、正则表达式分组内容，没有分组则没有该参数，则第三个参数变成了第二个参数，若有两个分组，则第三个参数变成了第四个参数
3、匹配项在字符串中的index
4、原字符串
举个例子：我们想把a1b2c3d4e5中的数字都加上1，变成a2b3c4d5e6
'a1b2c3d4e5'.replace(/\d/g,function(match,index,origin){
  console.log(index) // 打印一下index，无实际用途
  return parseInt(match)+1 // 这里需要用parseInt把它转换成数字，不然就变成字符串的拼接了
}

再举个有分组的例子: 同样是a1b2c3d4e5,我们想把数字+字母+数字类型中的字母给去掉，变成a12c34e5
'a1b2c3d4e5'.replace(/(\d)(\w)(\d)/g,function(match,group1,group2,group3,index,origin){
  console.log(match)
  return group1 + group3
}
就行了
好了，正则的学习就到这里
