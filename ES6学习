# let
  · JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
  · for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。
  · 不存在变量提升，var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
  · 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
举个例子：
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}

上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。
暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
  · 不允许重复声明，let不允许在相同作用域内，重复声明同一个变量。
  · 应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式，而不是函数声明语句。
  · 块级作用域是一个语句，将多个操作封装在一起，没有返回值。

#const
  · const声明一个只读的常量。一旦声明，常量的值就不能改变。
  · const一旦声明变量，就必须立即初始化，不能留到以后赋值。
  · const的作用域与let命令相同：只在声明所在的块级作用域内有效。
  · const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
  · const声明的常量，也与let一样不可重复声明。
      var message = "Hello!";
      let age = 25;

      // 以下两行都会报错
      const message = "Goodbye!";
      const age = 30;
  · const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
  举个例子：

  const foo = {};
  // 为 foo 添加一个属性，可以成功
  foo.prop = 123;
  foo.prop // 123
  // 将 foo 指向另一个对象，就会报错
  foo = {}; // TypeError: "foo" is read-only

  上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

# ES6中6中声明变量的方法
  var, function , const , let , import , class

# 顶层对象的属性
  顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。

